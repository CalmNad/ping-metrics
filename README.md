# Сервер и клиент для сбора статистики пинга заданной страницы

## Требования

Необходимо наличие установленных `npx` и `yarn`.

## Скачивание

`git clone https://github.com/CalmNad/ping-metrics.git ~/opt/test`

## Клиент

### Запуск

Предусмотрен запуск только в `dev` режиме:

```bash
cd ~/opt/test/client
yarn dev
```

### Memo

1. Для сбора статистики измеряется время загрузки html страницы без учета подгрузки ее ресурсов (мультимедиа, css, ...).
2. Часть данных, отсылаемая серверу, избыточна (сервер их не использует), но соответствует требованиям.
3. Для опроса "каждую секунду" используется `setInterval`, что подразумевает ("стараюсь каждую секунду, но могу чуть задержаться").
4. Писалось/проверялось под node 16.

### Реализация

При написании использовался javascript и подход применимый для POC, небольших решений, etc. Т.е. когда решение не требует много кода и не подразумевает развития в более сложный проект.

## Сервер

### Установка

```bash
cd ~/opt/test/server
npx -p node@16 yarn install
```

### Запуск

Предусмотрен запуск только в `dev` режиме:

```bash
cd ~/opt/test/server
yarn dev
```

### Memo

1. Вместо полноценных DTO и их маппинга используется typescript interfaces/types. Это дает проверку только на этапе написания. При необходимости проверок типов на этапе выполнения стоит посмотреть в сторону json схем и т.п. подходов.
2. Писалось/проверялось под node 16.

### Реализация

При реализации использовался typescript и подход на базе идей "чистой архитектуры". Имея более высокий порог вхождения он, тем не менее, значительно упрощает дальнейшее поддержание и развитие проекта. При этом позволяет легко менять используемые фреймворки, способы хранения и т.п. адаптируясь к изменениям требований.

Основные понятия и принципы взяты из идей "гексагональной архитектуры" (например: [Ports & Adapters](https://herbertograca.com/2017/09/14/ports-adapters-architecture) ), "чистой архитектуры" ( [Чистая
архитектура. Роберт Мартин](https://books.google.by/books/about/%D0%A7%D0%B8%D1%81%D1%82%D0%B0%D1%8F_%D0%B0%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D0%98%D1%81.html?id=d6JSDwAAQBAJ&source=kp_book_description&redir_esc=y) ) и DDD ( [Предметно-ориентированное проектирование. Эрик Эванс](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) ).

Далее - более подробно описаны базовые положения, для более простого понимания кода сервера.

#### Слои

Одна из основных целей при создании программных систем - управление сложностью. Для этого система разбивается на модули, а модули - на слои. Такой подход позволяет уменьшать количество объектов/понятий, которыми приходится оперировать разработчику в один момент времени, а так же снизить зацепление разных частей системы между собой.

В качестве слоев предполагаются:

- Слой бизнеса (domain), где содержится все, связанное с представлением реального бизнеса в системе.
- Слой приложения (application), где содержится логика создаваемого нами приложения.
- Слой адаптеров (adapters), где содержится код подключения/реализации используемых сервисов (например сервис хранения
данных о пингах в памяти).
- Слой инфраструктуры (infrastructure), где происходит настройка (bootstraping) приложения и связывание портов и адаптеров.

Есть несколько ключевых правил, связанных со слоями.

##### Первое правило - видимость слоев

- Domain ничего не знает о других слоях и код из него не может ничего вызывать из них.
- Application - знает о domain, но не знает об остальных. И так же не может к ним обращаться.
- Adapters - знает о domain и application, но не знает о infrastructure.

В итоге мы получаем однонаправленность зависимостей между слоями и возможность очень легко их подменять. Например, при смене фреймворка, который затрагивает только infrastructure и некоторые из adapters - мы не будем менять код приложения и доменной области.

##### Второе правило - DTO

Между слоями могут передаваться только простые данные (анемичные объекты). При этом внутри слоя - могут и должны (где это обоснованно) использоваться полноценные объекты.

Далее каждый из слоев рассмотрен подробнее.

##### Слой domain

Содержит модели и методы, существующие в бизнес логике (см. DDD). На примере нашей задачи - в бизнес логике есть метрики пинга: среднее и медианное время.

Но в бизнес логике не существует http протоколов, хранилищ данных в памяти и т.п. Соответственно тут не должно быть ни каких упоминаний/кода/... из этих областей.

Т.е. domain содержит понятия, существующие в бизнесе, который не знает о приложении.

В нашем случае получается достаточно "вырожденный слой" из-за малой функциональности тестового задания.

##### Слой application

Это уже уровень программной системы, которую мы создаем для бизнеса. Он содержит модели/код, которые нужны для реализации приложения, построенного вокруг domain. Тут есть понятия story или use cases (например story "а-ля" сервер получает от клиента и сохраняет данные по каждому ping запросу).

Основная задача уровня application - реализовать логику приложения используя понятия domain. При этом приложение не должно зависеть от:

- используемого фреймворка;
- используемых баз данных;
- протоколов связи;
- ...

Оно оперирует абстрактными понятиями. Точка входа в приложение - stories, которые принимают входные данные и работают с абстрактными хранилищами, вызывают абстрактные внешние сервисы, и используют при этом свои модели/методы и модели/методы из слоя domain.

Для описания интерфейса, который предоставляет приложение вовне и интерфейса, ожидаемого от реально используемых хранилищ и сервисов используются ports (см. гексагональная архитектура, порты и адаптеры). Фактически ports - это публичные контракты, набор соглашений, в виде interfaces и DTO. Они декларативны.

Пример описания порта можно посмотреть [тут](../blob/master/server/src/application/ports/storages/ping-data.port.ts).

Этот порт декларирует, что хранилище которое приложение готово использовать, должно предоставить два метода. А так же описывает что story будет передавать на вход этих методов и что ожидает получить на выходе.

В результате, конкретная реализация хранилища будет определяться на этапе запуска (bootstrap) приложения. В конечном итоге story, которая использует хранилище с таким port может "под капотом" получить postgres, in memory, или mock хранилище.

Есть два вида портов:

- Порт работающий на вход - описывает интерфейс story, которую будут использовать входные адаптеры (rest, grpc, cli, graphql, ...), т.е. те адаптеры, которые являются инициаторами действий в приложении.
- Порт работающий на выход - описывает интерфейс, который должен реализовать адаптер используемый из story (хранилища данных, службы отправки почты/sms, ...).

##### Слой adapters

Это конкретная реализация ports, объявленных в application, реализующих внешние сервисы/хранилища/... Именно тут принимаются решения об используемых библиотеках и фреймворках. И именно подмена адаптера позволяет, не трогая другие части приложения, изменить используемую БД, подменять реальные сервисы тестовыми имитациями и т.п.

Пример адаптера для http запросов можно мосмотреть [тут](../master/server/src/adapters/controllers/http/index.ts).

##### Слой infrastructure

Это слой, обеспечивающий настройку и запуск приложения. Его содержимое зависит от используемых фреймворков и библиотек. В нашем случае, это серверный vanillajs.

##### Файловая структура

Файловая структура является одним из способов управления сложностью. Она должна быть "кричащей" т.е. максимально понятно объяснять что и где лежит. Исходя из разбиения на слои текущее решение такое:

```text
adapters
  controllers
    http
      ...
    system
      ...
    ...
  storages
    ping-data
      ...
    ...
  ...
application
  ports
    stroties
      some-cool-story.port.ts
      some-another-cool-story.port.ts
      ...
    storages
      some-persistent-storage.port.ts
      ...
    ...
  stories
    some-cool-story.story.ts
    some-another-cool-story.story.ts
    ...
domain
  entities
    ...
  ...
infrastructure
  vanilla
    ...
  ...
```
